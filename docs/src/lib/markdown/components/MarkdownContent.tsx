import { useMemo, useEffect } from 'react';
import Markdown from 'markdown-to-jsx';
import type { MarkdownContentProps, TocItem } from '../types';
import { parseFrontmatter, removeTocPlaceholder } from '../utils/frontmatter';
import { generateToc } from '../utils/headings';
import { generateHeadingId } from '../utils/headings';
import { useActiveHeading } from './TableOfContents';
import { useToc } from '../../../contexts/TocContext';
import { parseCustomBlockDiv } from './CustomBlock';
import { LinkComponent } from '../plugins/links';
import { MarkdownCodeBlock, MarkdownPre } from './CodeBlock';
import { Heading } from './Heading';
import { createMermaidHtmlOverrides, processMermaidAsHtml } from '../plugins/mermaid';

// Custom heading component that prevents markdown formatting in headings
function createMarkdownHeading(level: number) {
  return function MarkdownHeading(props: any) {
    // Convert children to string and prevent markdown interpretation
    let text = '';
    if (typeof props.children === 'string') {
      text = props.children;
    } else if (Array.isArray(props.children)) {
      text = props.children.map(child =>
        typeof child === 'string' ? child : child.props?.children || ''
      ).join('');
    } else if (props.children?.props?.children) {
      text = props.children.props.children;
    }



    // Generate ID from text
    const id = generateHeadingId(text);

    return <Heading level={level} id={id} {...props}>{text}</Heading>;
  };
}

export function MarkdownContent({
  content,
  options = {},
  className = ''
}: MarkdownContentProps) {
  const {
    enableToc = true,
    enableCodeFocus = true,
    enableHtmlBlocks = true,
    enableLinkProcessing = true,
    tocDepth = { min: 2, max: 4 },
    baseUrl
  } = options;

  // Parse frontmatter and process content
  const { processedContent, toc, frontmatter } = useMemo(() => {
    const { content: rawContent, frontmatter: fm, hasToc } = parseFrontmatter(content);

    let processed = rawContent;

    // Process Mermaid diagrams BEFORE markdown parsing
    processed = processMermaidAsHtml(processed);

    // Remove TOC placeholder if present
    if (hasToc || enableToc) {
      processed = removeTocPlaceholder(processed);
    }

    // Escape underscores in headings to prevent italic interpretation
    processed = processed.replace(/^(#{1,6})\s+(.+)$/gm, (match, hashes, title) => {
      // Escape underscores only in the title part
      const escapedTitle = title.replace(/_/g, '\\_');
      return `${hashes} ${escapedTitle}`;
    });

    // Generate TOC if needed
    let tocItems: TocItem[] = [];
    if ((hasToc || enableToc) && processed) {
      tocItems = generateToc(processed, tocDepth.min, tocDepth.max);

      // Add heading IDs to content for anchor links
      // Note: We don't modify the content string here because markdown-to-jsx
      // doesn't support the {#id} syntax and renders it as text.
      // Instead, IDs are generated by the custom Heading components.
    }

    return {
      processedContent: processed,
      toc: tocItems.length > 0 ? tocItems : undefined,
      frontmatter: fm
    };
  }, [content, enableToc, tocDepth]);

  // Track active heading and send to context
  const activeHeadingId = useActiveHeading(toc || []);
  const tocContext = useToc();

  // Send TOC and activeId to context
  useEffect(() => {
    if (tocContext && toc) {
      tocContext.setToc(toc);
      tocContext.setActiveId(activeHeadingId);
    }
  }, [toc, activeHeadingId, tocContext]);

  // Create markdown overrides
  const markdownOverrides = useMemo(() => {
    const overrides: any = {
      // Headings with anchor support - prevent markdown interpretation in headings
      h1: createMarkdownHeading(1),
      h2: createMarkdownHeading(2),
      h3: createMarkdownHeading(3),
      h4: createMarkdownHeading(4),
      h5: createMarkdownHeading(5),
      h6: createMarkdownHeading(6),

      // Prevent underscore interpretation as italics
      em: (props: any) => {
        const text = typeof props.children === 'string' ? props.children : props.children;
        // If text contains underscores, render as plain text instead of italics
        if (typeof text === 'string' && text.includes('_')) {
          return <span>{text}</span>;
        }
        return <em {...props} />;
      },

      // Prevent underscore interpretation in strong tags
      strong: (props: any) => {
        const text = typeof props.children === 'string' ? props.children : props.children;
        // If text contains underscores, render as plain text instead of bold
        if (typeof text === 'string' && text.includes('_')) {
          return <span>{text}</span>;
        }
        return <strong {...props} />;
      },
    };

    // Add code block support
    if (enableCodeFocus) {
      overrides.pre = MarkdownPre;
      overrides.code = MarkdownCodeBlock;
    }

    // Add HTML blocks support
    if (enableHtmlBlocks) {
      overrides.div = parseCustomBlockDiv;
    }

    // Add link processing
    if (enableLinkProcessing) {
      overrides.a = (props: any) => <LinkComponent {...props} baseUrl={baseUrl} />;
    }

    // Add Mermaid support
    const mermaidOverrides = createMermaidHtmlOverrides();
    Object.assign(overrides, mermaidOverrides);

    return overrides;
  }, [enableCodeFocus, enableHtmlBlocks, enableLinkProcessing, baseUrl]);

  const markdownOptions = {
    overrides: markdownOverrides,
    wrapper: 'div' as any,
    forceBlock: true
  };

  const containerClassName = `markdown-content ${className}`.trim();

  return (
    <div className={containerClassName}>
      <div className="markdown-body">
        {frontmatter.title && (
          <header className="markdown-header">
            <h1 className="markdown-title">{frontmatter.title}</h1>
            {frontmatter.description && (
              <p className="markdown-description">{frontmatter.description}</p>
            )}
          </header>
        )}

        <Markdown options={markdownOptions}>
          {processedContent}
        </Markdown>
      </div>
    </div>
  );
}

/**
 * Hook for processing markdown content without rendering
 */
export function useMarkdownProcessor(content: string, options: any = {}) {
  return useMemo(() => {
    const { content: rawContent, frontmatter, hasToc } = parseFrontmatter(content);

    const processedContent = hasToc ? removeTocPlaceholder(rawContent) : rawContent;

    const toc = hasToc || options.enableToc
      ? generateToc(processedContent, options.tocDepth?.min || 2, options.tocDepth?.max || 4)
      : undefined;

    return {
      content: processedContent,
      frontmatter,
      toc,
      hasToc
    };
  }, [content, options]);
}

export default MarkdownContent;
